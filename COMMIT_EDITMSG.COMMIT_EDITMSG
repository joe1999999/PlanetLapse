PlanetLapse V1.0

# --------------
# Please enter the commit message for your changes. Everything below
# this paragraph is ignored, and an empty message aborts the commit.
# Just close the window to accept your message.
diff --git a/__pycache__/app.cpython-313.pyc b/__pycache__/app.cpython-313.pyc
new file mode 100644
index 0000000..779b386
Binary files /dev/null and b/__pycache__/app.cpython-313.pyc differ
diff --git a/__pycache__/appAI.cpython-313.pyc b/__pycache__/appAI.cpython-313.pyc
new file mode 100644
index 0000000..db0409b
Binary files /dev/null and b/__pycache__/appAI.cpython-313.pyc differ
diff --git a/__pycache__/hello.cpython-313.pyc b/__pycache__/hello.cpython-313.pyc
new file mode 100644
index 0000000..46ef890
Binary files /dev/null and b/__pycache__/hello.cpython-313.pyc differ
diff --git a/__pycache__/testing.cpython-313.pyc b/__pycache__/testing.cpython-313.pyc
new file mode 100644
index 0000000..3f19555
Binary files /dev/null and b/__pycache__/testing.cpython-313.pyc differ
diff --git a/app.py b/app.py
new file mode 100644
index 0000000..53e6adb
--- /dev/null
+++ b/app.py
@@ -0,0 +1,203 @@
+from flask import Flask, request, jsonify, render_template, send_file, Response
+import requests
+import cv2
+import os
+from datetime import datetime, timedelta
+import threading
+import ffmpeg  # Import ffmpeg-python
+
+app = Flask(__name__, static_folder='static')
+
+# Global variables to track progress and cancellation
+progress = {
+    "total_images": 0,
+    "downloaded_images": 0,
+    "status": "idle"  # Can be "idle", "downloading", "creating_timelapse", "converting", "done"
+}
+cancel_event = threading.Event()  # Thread-safe event for cancellation
+
+@app.route('/static/timelapse.mp4')
+def serve_video():
+    path = 'static/timelapse.mp4'
+    range_header = request.headers.get('Range', None)
+    if range_header:
+        # Handle range requests
+        return Response(response=open(path, 'rb'), content_type='video/mp4', status=206, direct_passthrough=True)
+    else:
+        # Serve the full file
+        return send_file(path, mimetype='video/mp4')
+
+def create_timelapse_process(start_date, end_date):
+    global progress
+
+    # Push the Flask application context
+    with app.app_context():
+        try:
+            # Fetch images for the date range
+            images = []
+            current_date = datetime.strptime(start_date, "%Y-%m-%d")
+            end_date_obj = datetime.strptime(end_date, "%Y-%m-%d")
+
+            # Update progress
+            progress["status"] = "downloading"
+
+            # Fetch all images for the date range
+            while current_date <= end_date_obj and not cancel_event.is_set():
+                date_str = current_date.strftime("%Y-%m-%d")
+                api_url = f"https://epic.gsfc.nasa.gov/api/natural/date/{date_str}"
+                response = requests.get(api_url)
+                if response.status_code == 200:
+                    images.extend(response.json())
+                current_date += timedelta(days=1)
+
+            # Check if cancellation was requested
+            if cancel_event.is_set():
+                progress["status"] = "idle"
+                cancel_event.clear()  # Reset the event
+                cleanup_images()  # Clean up downloaded images
+                return
+
+            # Check if images are available
+            if not images:
+                progress["status"] = "idle"
+                return
+
+            # Update total_images to reflect the actual number of images
+            progress["total_images"] = len(images)
+            progress["downloaded_images"] = 0
+
+            # Create a directory to store downloaded images
+            if not os.path.exists("images"):
+                os.makedirs("images")
+
+            # Download images from NASA EPIC API
+            for idx, image in enumerate(images):
+                if cancel_event.is_set():
+                    break
+
+                image_url = f"https://epic.gsfc.nasa.gov/archive/natural/{image['date'].split(' ')[0].replace('-', '/')}/png/{image['image']}.png"
+                image_data = requests.get(image_url).content
+                with open(f"images/image_{idx}.png", "wb") as f:
+                    f.write(image_data)
+
+                # Update progress
+                progress["downloaded_images"] = idx + 1
+
+            # Check if cancellation was requested
+            if cancel_event.is_set():
+                progress["status"] = "idle"
+                cancel_event.clear()  # Reset the event
+                cleanup_images()  # Clean up downloaded images
+                return
+
+            # Create a timelapse video using OpenCV
+            progress["status"] = "creating_timelapse"
+            timelapse_path = "static/timelapse_raw.mp4"  # Temporary raw video
+            create_timelapse("images", timelapse_path)
+
+            # Convert the video to a web-friendly format using FFmpeg
+            progress["status"] = "converting"
+            web_friendly_path = "static/timelapse.mp4"
+            convert_to_web_friendly(timelapse_path, web_friendly_path)
+
+            # Clean up downloaded images and raw video
+            cleanup_images()
+            if os.path.exists(timelapse_path):
+                os.remove(timelapse_path)
+
+            # Update progress
+            progress["status"] = "done"
+            print("Timelapse creation and conversion completed. Progress status set to 'done'.")
+        except Exception as e:
+            progress["status"] = "idle"
+            print(f"Error in timelapse process: {e}")
+
+def cleanup_images():
+    """Delete all downloaded images."""
+    temp_images_directory_path = 'images/'
+    if os.path.exists(temp_images_directory_path):
+        for filename in os.listdir(temp_images_directory_path):
+            file_path = os.path.join(temp_images_directory_path, filename)
+            try:
+                if os.path.isfile(file_path):
+                    os.remove(file_path)
+                    print(f"Deleted: {file_path}")
+            except Exception as e:
+                print(f"Error deleting {file_path}: {e}")
+
+def create_timelapse(image_folder, output_path, fps=5):
+    # Get list of images in the folder
+    images = [img for img in os.listdir(image_folder) if img.endswith(".png")]
+    images.sort()  # Ensure images are in the correct order
+
+    # Read the first image to get dimensions
+    first_image_path = os.path.join(image_folder, images[0])
+    frame = cv2.imread(first_image_path)
+    height, width, layers = frame.shape
+
+    # Initialize video writer
+    fourcc = cv2.VideoWriter_fourcc(*'mp4v')  # Codec for MP4
+    video = cv2.VideoWriter(output_path, fourcc, fps, (width, height))
+
+    # Add images to the video
+    for image in images:
+        image_path = os.path.join(image_folder, image)
+        frame = cv2.imread(image_path)
+        video.write(frame)
+
+    # Release the video writer
+    video.release()
+
+def convert_to_web_friendly(input_path, output_path):
+    """Convert the video to a web-friendly format using FFmpeg."""
+    try:
+        (
+            ffmpeg
+            .input(input_path)
+            .output(output_path, vcodec='libx264', pix_fmt='yuv420p', crf=23, preset='medium')
+            .run(overwrite_output=True)
+        )
+        print(f"Video converted to web-friendly format: {output_path}")
+    except ffmpeg.Error as e:
+        print(f"FFmpeg error: {e.stderr.decode('utf-8')}")
+        raise
+
+@app.route("/")
+def index():
+    return render_template("index.html")
+
+@app.route('/get_timelapse', methods=['POST'])
+def get_timelapse():
+    global progress
+
+    # Reset cancellation event
+    cancel_event.clear()
+
+    # Get start and end dates from the frontend
+    data = request.get_json()
+    start_date = data.get('start_date')
+    end_date = data.get('end_date')
+
+    # Validate dates
+    if not start_date or not end_date:
+        return jsonify({"error": "Both start and end dates are required."}), 400
+
+    # Start the timelapse process in a separate thread
+    progress["status"] = "downloading"
+    thread = threading.Thread(target=create_timelapse_process, args=(start_date, end_date))
+    thread.start()
+
+    return jsonify({"message": "Timelapse creation started."})
+
+@app.route('/progress', methods=['GET'])
+def get_progress():
+    global progress
+    return jsonify(progress)
+
+@app.route('/cancel', methods=['POST'])
+def cancel():
+    cancel_event.set()  # Set the cancellation event
+    return jsonify({"message": "Cancellation requested."})
+
+if __name__ == "__main__":
+    app.run(debug=True)
\ No newline at end of file
diff --git a/static/timelapse.mp4 b/static/timelapse.mp4
new file mode 100644
index 0000000..08f304b
Binary files /dev/null and b/static/timelapse.mp4 differ
diff --git a/templates/index.html b/templates/index.html
new file mode 100644
index 0000000..13c231f
--- /dev/null
+++ b/templates/index.html
@@ -0,0 +1,144 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+  <meta charset="UTF-8">
+  <meta name="viewport" content="width=device-width, initial-scale=1.0">
+  <title>Timelapse Creator</title>
+  <!-- Bootstrap CSS -->
+  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
+  <!-- Custom CSS -->
+  <style>
+    body {
+      background-color: #f8f9fa;
+    }
+    .container {
+      max-width: 800px;
+      margin-top: 50px;
+    }
+    .video-container {
+      margin-top: 20px;
+      text-align: center;
+    }
+    #timelapseVideo {
+      max-width: 100%;
+      border-radius: 10px;
+      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
+    }
+    .status-text {
+      font-size: 1.1rem;
+      font-weight: 500;
+      margin-top: 20px;
+    }
+    .btn-custom {
+      margin: 5px;
+      padding: 10px 20px;
+      font-size: 1rem;
+    }
+    footer {
+      background-color: #343a40;
+      color: white;
+      text-align: center;
+      padding: 10px 0;
+      margin-top: auto;
+    }
+    footer p {
+      margin: 0; /* Remove default margin for the paragraph */
+    }
+    footer a {
+      color: #ffc107;
+      text-decoration: none;
+    }
+    footer a:hover {
+      text-decoration: underline;
+    }
+  </style>
+</head>
+<body>
+  <div class="container">
+    <h1 class="text-center mb-4">PlanetLapse V1.0</h1>
+    <p>We use The EPIC NASA API to create a timelapse video of earth between 2 given dates.The EPIC API provides information on the daily imagery collected by DSCOVR's Earth Polychromatic Imaging Camera (EPIC) instrument. Uniquely positioned at the Earth-Sun Lagrange point, EPIC provides full disc imagery of the Earth and captures unique perspectives of certain astronomical events such as lunar transits using a 2048x2048 pixel CCD (Charge Coupled Device) detector coupled to a 30-cm aperture Cassegrain telescope.
+    </p>
+    <div class="card shadow-sm p-4">
+      <form id="timelapseForm">
+        <div class="mb-3">
+          <label for="start_date" class="form-label">Timelapse Start Date:</label>
+          <input type="date" class="form-control" id="start_date" name="start_date" required>
+        </div>
+        <div class="mb-3">
+          <label for="end_date" class="form-label">Timelapse End Date:</label>
+          <input type="date" class="form-control" id="end_date" name="end_date" required>
+        </div>
+        <div class="d-grid gap-2">
+          <button type="submit" class="btn btn-primary btn-custom">Create Timelapse</button>
+          <button type="button" id="cancelButton" class="btn btn-danger btn-custom" disabled>Cancel</button>
+        </div>
+      </form>
+      <p id="status" class="status-text text-center mt-3">Status: Idle</p>
+    </div>
+    <div class="video-container">
+      <video id="timelapseVideo" controls style="display:none;"></video>
+    </div>
+  </div>
+   <!-- Footer -->
+  <footer>
+    <div class="text-center">
+      <p>Created by <strong>Youcef Soukkou</strong> | <a href="mailto:soukkouyoucef@protonmail.com">soukkouyoucef@protonmail.com</a></p>
+    </div>
+  </footer>
+
+  <!-- Bootstrap JS and dependencies -->
+  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js"></script>
+  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.min.js"></script>
+  <!-- Custom JS -->
+  <script>
+    const form = document.getElementById('timelapseForm');
+    const cancelButton = document.getElementById('cancelButton');
+    const statusText = document.getElementById('status');
+    const videoElement = document.getElementById('timelapseVideo');
+
+    form.addEventListener('submit', async (e) => {
+      e.preventDefault();
+      const startDate = document.getElementById('start_date').value;
+      const endDate = document.getElementById('end_date').value;
+
+      // Disable form and enable cancel button
+      form.querySelector('button').disabled = true;
+      cancelButton.disabled = false;
+
+      // Start the timelapse process
+      const response = await fetch('/get_timelapse', {
+        method: 'POST',
+        headers: { 'Content-Type': 'application/json' },
+        body: JSON.stringify({ start_date: startDate, end_date: endDate }),
+      });
+      const data = await response.json();
+      console.log(data.message);
+
+      // Poll progress
+      const interval = setInterval(async () => {
+        const progressResponse = await fetch('/progress');
+        const progress = await progressResponse.json();
+        statusText.textContent = `Status: ${progress.status} (${progress.downloaded_images}/${progress.total_images})`;
+
+        if (progress.status === 'done') {
+          clearInterval(interval);
+          form.querySelector('button').disabled = false;
+          cancelButton.disabled = true;
+          videoElement.src = 'static/timelapse.mp4';
+          videoElement.style.display = 'block';
+        } else if (progress.status === 'idle') {
+          clearInterval(interval);
+          form.querySelector('button').disabled = false;
+          cancelButton.disabled = true;
+        }
+      }, 1000);
+    });
+
+    cancelButton.addEventListener('click', async () => {
+      const response = await fetch('/cancel', { method: 'POST' });
+      const data = await response.json();
+      console.log(data.message);
+    });
+  </script>
+</body>
+</html>
\ No newline at end of file